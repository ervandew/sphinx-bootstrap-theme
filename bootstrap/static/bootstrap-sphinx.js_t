var sphinx = window.sphinx || {};
sphinx['init'] = function($win, $nav, $subnav){
  /**
   * Walk the TOC allowing it to be modified based on where it's positioned or
   * truncated according to maxLevel.
   *
   * @param $ul The toc to walk.
   * @param visitor Optional function to execute on each item.
   * @param maxLevel Optional max toc level, above which items will be removed.
   */
  sphinx['walkToc'] = function($ul, visitor, maxLevel) {
    // Find all a "internal" tags, traversing recursively.
    var findA = function($elem, l) {
      var level = l || 0,
        $items = $elem.find('> li > a.internal, > ul, > li > ul');

      if (maxLevel >= 0 && level > maxLevel){
        $elem.remove();
        return;
      }

      // Iterate everything in order.
      $items.each(function(index, item) {
        var $item = $(item);
        if (visitor) {
          visitor($item, level);
        }
        if ($item.is('ul')) {
          // Recurse.
          findA($(item), level + 1);
        }
      });
    };

    findA($ul);
  };

  /**
   * Initialize top nav menu.
   *
   * @param $menu: The menu element.
   * @param max_depth: Optional maxdepth of the menu.
   */
  sphinx['initMenu'] = function($menu, maxdepth){
    var $toc = $menu.find('> ul').addClass('dropdown-menu');
    $menu.replaceWith($toc);

    // convert sphinx 'current' to bootstrap 'active'
    $toc.find('li.current').each(function(index, li){
      $(li).addClass('active');
    });

    sphinx.walkToc($toc, sphinx.initMenuItem, maxdepth);
  };

  /**
   * Initialize menu items.
   *
   * @param item: The current item being visited.
   * @param level: The current level being visited.
   */
  sphinx['initMenuItem'] = function($item, level){
    if($item.is('ul')){
      if($item.is('.simple') && $item.children().length === 0){
        $item.remove();
      }else{
        $item.addClass('dropdown-menu');
        $item.parent().addClass('dropdown-submenu');
      }
    }
  };

  /**
   * Get the absolute top offset of the supplied element if the window was
   * scrolled to the top of the document.
   *
   * @param $el The element to find the top offset of.
   */
  sphinx['absoluteOffsetTop'] = function($el){
    var scrollTop = $win.scrollTop();
    $win.scrollTop(0);
    $subnav.removeClass('subnav-fixed');
    var top = $el.offset().top;
    $win.scrollTop(scrollTop);
    return top;
  };

  {%- if theme_page_toc_position == 'subnav' %}
  /**
   * Initialize the subnav functionality, handling fixing it to the top when
   * scrolling, dealing with overflow, etc.
   *
   * Boostrap 2.1 is suppose to have a subnav implementation, which hopefully
   * will take care of most of this logic.
   */
  sphinx['initSubNav'] = function(){
    var $subnav_inner = $subnav.find('.navbar-inner');
    var $level0 = $subnav_inner.find('> ul');
    var $level1 = $level0.find('> li > ul');
    if (!$level1.children().length){
      $subnav.remove();
      return;
    }

    $subnav.find('.navbar-inner').append($level1.addClass('nav'));
    $level0.remove();
    var $after = $('.content > .section > h1');
    var $lead = $after.siblings().first();
    if ($lead.is('.lead')){
      $after = $lead;
    }
    $subnav.insertAfter($after).css('visibility', 'visible');

    sphinx.walkToc($level1, null, 0);

    var navTop = 0;
    function updateNavTop() {
      navTop = sphinx.absoluteOffsetTop($subnav) - $nav.outerHeight();
    }

    function hoverscroll(){
      var width = ($subnav.css('position') == 'fixed') ?
        $('.body').width() : $subnav_inner.width();
      $level1.hoverscroll({
        arrowOpacity: 0.3,
        width: width,
        height: $subnav_inner.height()
      });
    }
    $win.on('load resize', function(){
      updateNavTop();
      $win.scroll();
    });
    $win.on('hoverscroll scroll', function(){
      var scrollTop = $win.scrollTop();
      if (scrollTop > navTop) {
        if (!$subnav.hasClass('subnav-fixed')){
          // account for the page not being long enough to make the subnav fixed
          // without it immediately scrolling back and forcing back to static
          // positioning.
          var height = $(document).height() - navTop - $subnav.outerHeight(true);
          if (height > $win.height()){
            $subnav.addClass('subnav-fixed');
          }
        }
      } else {
        $subnav.removeClass('subnav-fixed');
      }
      hoverscroll();
    }).scroll();
  };
  {%- endif %}

  /**
   * Initialize handling of hash links, and loading of a page linking to a
   * hash, to account for fixed position header elements.
   */
  sphinx['initHashLinks'] = function(){
    // alter element ids so we can handle hash links ourselves accounting for
    // fixed positioned nav elements.
    $('.content *[id]').each(function(index, el){
      var $el = $(el);
      $el.attr('id', '_' + $el.attr('id'));
    });
    $win.hashchange(function(){
      $win = $(this);
      if (location.hash){
        var $target = $(location.hash.replace(/^#/, '#_'));
        var padding = parseInt($target.css('padding-top').replace('px', ''), 10)
        var spacing = isNaN(padding) ? 0 : padding;
        var navOffset = spacing > 10 ? -(spacing - 5) : 5;
        var firstSection = '.content > .section';
        if ($target.is(firstSection) ||
           ($target.is('span') && $target.parent().is(firstSection)))
        {
          $win.scrollTop(0);
          // for android browsers
          $win.load(function(){$win.scrollTop(0);});
          return;
        }

        if ($nav.css('position') == 'fixed'){
          navOffset += $nav.outerHeight();
        }

        {%- if theme_page_toc_position == 'subnav' %}
        $subnav.addClass('subnav-fixed');
        if ($subnav.css('position') == 'fixed' && $subnav.is(':visible')){
          navOffset += $subnav.outerHeight();
        }
        {%- endif %}

        $win.scrollTop($win.scrollTop() + $target.offset().top - navOffset);
        var $animate = $target;
        if ($animate.is('.section')){
          $animate = $animate.find('> h2');
        } else if ($animate.is('ul')){
          $animate = $animate.find('li:first-child :first-child');
        }
        $animate.animate({opacity: 0.4}, 1000, function(){
          $animate.animate({opacity: 1}, 1000);
        });
        {%- if theme_page_toc_position == 'subnav' %}
        if ($subnav.css('position') == 'fixed'){
          $win.scroll();
        }
        {%- endif %}
      }
    }).hashchange();
  };

  /**
   * Translate sphix style names to the corresponding bootstrap style name.
   */
  sphinx['bootstrapStyles'] = function(){
    var styles = {
      '.admonition-title': 'alert-heading',
      '.admonition.note, .admonition.hint, .admonition.tip': 'alert alert-info',
      '.admonition.warning, .admonition.attention, .admonition.caution, .admonition.important': 'alert',
      '.admonition.error, .admonition.danger': 'alert alert-error',
    };
    for (var sphinxStyle in styles){
      $(sphinxStyle).addClass(styles[sphinxStyle]);
    }

    // convert to inline code tags
    $('.docutils.literal').replaceWith(function(){
      var $spans = $(this).children('span.pre');
      if ($spans.length) {
        return $('<code/>').append($spans.contents().map(function(){
          return $(this).text();
        }).toArray().join(' '));
      }
      return this;
    });
  };

  sphinx['scrollspy'] = function(){
    $('.nav *[href^=#]').each(function(index, el){
      var $el = $(el);
      $el.attr('data-target', '#_' + $el.attr('href').replace('#', ''));
    });

    var navOffset = 10;
    navOffset += $nav.outerHeight() * 2;
    {%- if theme_page_toc_position == 'subnav' %}
    navOffset += $subnav.outerHeight();
    {%- endif %}
    $('body').scrollspy({offset: navOffset});

    {%- if theme_page_toc_position == 'subnav' %}
    $('body').bind('activate', function(e){
      var $target = $(e.target);
      var $list = $subnav.find('.listcontainer');
      var left = $target.position().left;
      var right = left + $target.width();
      var scroll = $list.scrollLeft();

      if (right > ($list.width() - scroll)){
        $list.scrollLeft(right);
        $win.trigger('hoverscroll');
      }else if (left < scroll){
        $list.scrollLeft(left);
        $win.trigger('hoverscroll');
      }
    });
    $win.on('scroll', function(){
      if($win.scrollTop() == 0){
        $subnav.find('li.active').removeClass('active');
        $subnav.find('.listcontainer').scrollLeft(0);
        $win.trigger('hoverscroll');
      }
    });
    {%- elif theme_page_toc_position == 'nav' %}
    $win.on('scroll', function(){
      if($win.scrollTop() == 0){
        $('#navbar .nav').find('li.active').removeClass('active');
      }
    });
    {%- endif %}
  };

  // Add structure to TOC's.
  $('.dropdown-menu').each(function() {
    $(this).find('li').each(function() {
      $(this).parent().append(this);
    });
  });

  sphinx.initMenu($('.globaltoc'));
  {%- if theme_page_toc_position == 'nav' %}
  var $toc = $('.localtoc > ul');
  $toc.replaceWith($toc.find('li:first-child > ul'));
  sphinx.initMenu($('.localtoc'), {{ theme_page_toc_maxdepth }});
  {%- elif theme_page_toc_position == 'subnav' %}
  sphinx.initSubNav();
  {%- elif theme_page_toc_maxdepth|int %}
  sphinx.walkToc($('.page-toc > ul'), null, {{ theme_page_toc_maxdepth }});
  {%- endif %}

  // Enable dropdown.
  $('.dropdown-toggle').dropdown();

  // fix the navbar to the top w/ js so that if the js doesn't load, hash links
  // aren't screwed (must be before initHashLinks).
  $nav.addClass('navbar-fixed-top');
  $('body').addClass('with-fixed-nav');

  sphinx.bootstrapStyles();
  sphinx.initHashLinks();
  sphinx.scrollspy();
};

$(document).ready(function() {
  sphinx.init($(window), $('#navbar'), $('.subnav'));
});
